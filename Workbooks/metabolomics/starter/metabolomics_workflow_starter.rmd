---
title: "Metabolomics Analysis Workflow for Multiomics Integration"
version: "1.0"
author: "Your fancy self"
output:
  html_document:
    code_folding: true
    self_contained: true
    toc: true # Enable TOC for navigation
    warning: false
    message: false
---

# Initial R environment setup
## Checks your R environment for the required packages to run MultiScholaR, and installs them if they are not.

```{r MultiScholaR FIRST INSTALL, eval=FALSE}
installMultiScholaR <- function(verbose = TRUE) {
    # Install devtools if missing
    if (!requireNamespace("devtools", quietly = TRUE)) {
        install.packages("devtools")
    }

    # Detach if loaded
    if ("package:MultiScholaR" %in% search()) {
        try(detach("package:MultiScholaR", unload = TRUE, force = TRUE), silent = TRUE)
    }

    # Unload namespace
    try(unloadNamespace("MultiScholaR"), silent = TRUE)


    devtools::install_github(
        "APAF-BIOINFORMATICS/MultiScholaR",
        ref = "main", # Main branch
        dependencies = TRUE,
        upgrade = "never",
        force = TRUE
    )

    # Load it
    library(MultiScholaR)
}

installMultiScholaR()
loadDependencies()
```

# START HERE if you already have MultiScholaR installed
## Loads the package and its dependencies.

```{r Load MultiScholaR}
library(MultiScholaR) # Assuming core package exists
loadDependencies() # Load necessary libraries
```

# Set up your environment and project directory
## Establishes a standardized directory structure for the metabolomics project.

```{r Project Environment Management}
# Directory Management
## Set up the project directory structure
## This section sets up the project directory structure for MultiScholaR
## Directory management can be challenging, particularly when managing objects
## across multiple chunks within a single R Markdown document.
experiment_label <- "workshop_data"
# Setup for the central pillars of molecular biology
project_dirs <- setupDirectories(
    #omic_types = "metabolomics"
    # Or: 
    omic_types = c("proteomics", "metabolomics", "transcriptomics"),
    , label = experiment_label,
    force = FALSE # Set to TRUE to skip prompts if dirs exist
)
```

# At this step, please copy your data and other necessary files into the appropriate directories
## Define input files, parameters, and load configuration.

```{r Data Management and Parameters}
## Input Parameters for Quality Control
## Parameters in this section are experiment-specific. Their default parameters
## are intended as a guide only - every source of variance is different just as
## every set of proteins going through a mass spectrometer is different!
## One size does not fit all and you *will* most likely need to fine tune these
## to get the most out of your data.
config_list <- readConfigFile(file = file.path(project_dirs$metabolomics$base_dir, "config.ini"))

# Metabolomics Input File Management
## Define the filenames for your metabolomics quantification results.
## Files should be in 'data/metabolomics'. Set to NULL if not used.
metabolite_filenames <- list(
    LCMS_Neg = "m_MTBLS2322_LC-MS_negative_hilic_metabolite_profiling_v2_maf.tsv",
    LCMS_Pos = NULL,
    GCMS_Pos = NULL,
    GCMS_Neg = "m_MTBLS2322_GC-MS___metabolite_profiling_v2_maf.tsv"
)

# --- Load Metabolomics Data into a Named List ---
metabolite_data_tbl <- metabolite_filenames |>
    purrr::keep(~ !is.null(.x)) |> # Keep only non-NULL filenames
    purrr::map(~ {
        file_path <- file.path(project_dirs$metabolomics$data_dir, "metabolomics", .x)
        if (file.exists(file_path)) {
            log_info("Loading: {basename(file_path)}")
            tryCatch(
                vroom::vroom(file_path, show_col_types = FALSE),
                error = function(e) { # Handle potential loading errors
                    log_error("Failed to load {basename(file_path)}: {e$message}")
                    NULL
                }
            )
        } else {
            log_warn("File not found, skipping: {file_path}")
            NULL # Return NULL for missing files
        }
    }) |>
    purrr::compact() # Remove NULL elements from missing/failed files

## Please supply your organism's taxon ID here
taxon_id <- "244366"
## Please supply your organism's name here
organism_name <- "Klebsiella variicola"
```

# Set your design matrix (for the first time)
## Interactively create the design matrix linking samples to experimental conditions.

```{r Design Matrix Setup}
if (exists("metabolite_design_matrix", envir = .GlobalEnv)) {
    print("Design matrix already set :) No need to run app again!")
} else {
    RunApplet("designMatrix")
}
# Comment in if you wish to run manually
# RunApplet("designMatrix")
```

# If you have the design matrix stored from a previous run, you can read it in here, otherwise skip
## Optional step to load a pre-existing design matrix.

```{r Design Matrix Read In (optional), eval=FALSE}

metabolite_data_cln <- metabolite_data_tbl 
str(metabolite_data_cln)

# Define the prefix to remove
prefix_to_remove <- "102.100.100/" # Literal string for fixed=TRUE matching

# Check if the list exists and has content
if (exists("metabolite_data_cln") && is.list(metabolite_data_cln) && length(metabolite_data_cln) > 0) {
    
    log_info("Cleaning sample name prefixes in \'metabolite_data_cln\'...")
    
    metabolite_data_cln <- lapply(metabolite_data_cln, function(df) {
      current_colnames <- colnames(df)
      # Use fixed = TRUE for literal matching, which is safer and faster here
      new_colnames <- gsub(prefix_to_remove, "", current_colnames, fixed = TRUE) 
      colnames(df) <- new_colnames
      return(df)
    })
    
    log_info("Finished cleaning sample name prefixes.")
    
    # Optional: Verify the change
    # log_info("Structure of \'metabolite_data_cln\' after cleaning names:")
    # str(metabolite_data_cln)
    
} else {
    log_warn("\'metabolite_data_cln\' not found or empty. Skipping sample name cleaning.")
}
# This chunk allows loading a previously saved design matrix.
design_matrix_file <- file.path(project_dirs$metabolomics$source_dir, "design_matrix_metabolomics.tab")
if (file.exists(design_matrix_file)) {
    metabolite_design_matrix <- read.table(
        file = design_matrix_file,
        sep = "\t",
        header = TRUE,
        stringsAsFactors = FALSE
    )
    log_info("Loaded design matrix from: {design_matrix_file}")

    # Check if metabolite_data_cln exists and is a list
    if (exists("metabolite_data_cln") && is.list(metabolite_data_cln) && length(metabolite_data_cln) > 0) {
        log_info("Aligning data frames in 'metabolite_data_cln' with loaded design matrix...")

        metabolite_data_cln <- lapply(seq_along(metabolite_data_cln), function(i) {
            current_df <- metabolite_data_cln[[i]]
            df_name <- names(metabolite_data_cln)[i] # Get name for logging
            if (is.null(df_name) || df_name == "") df_name <- paste("DataFrame", i)

            # Identify sample columns present in both the current df and the design matrix
            sample_cols_in_df <- intersect(colnames(current_df), design_matrix$Run)

            if (length(sample_cols_in_df) == 0) {
                log_warn("No matching sample columns found for '{df_name}'. Skipping alignment.")
                return(current_df) # Return unmodified
            }

            # Identify metadata columns (those not identified as sample columns)
            metadata_cols <- setdiff(colnames(current_df), sample_cols_in_df)

            # Filter design matrix to keep only the rows relevant to this df's sample columns
            design_matrix_filtered <- metabolite_design_matrix[metabolite_design_matrix$Run %in% sample_cols_in_df, , drop = FALSE]

            # Order the sample columns according to the filtered design matrix
            ordered_sample_cols <- design_matrix_filtered$Run

            # Reconstruct the dataframe with metadata first, then ordered sample columns
            # Ensure all original columns are accounted for and in the correct order
            final_df <- current_df[, c(metadata_cols, ordered_sample_cols), drop = FALSE]

            log_info("Aligned '{df_name}'. Dimensions: {nrow(final_df)}x{ncol(final_df)}")
            return(final_df)
        })

        # Restore original names if they existed
        if (!is.null(names(metabolite_data_cln))) {
             names(metabolite_data_cln) <- names(metabolite_data_cln)
        }

        log_info("Finished aligning data frames in 'metabolite_data_cln'.")

    } else {
        log_warn("'metabolite_data_cln' not found, is not a list, or is empty. Skipping alignment.")
    }

} else {
    log_warn("Design matrix file not found at: {design_matrix_file}. Skipping read-in.")
}

# Optional: Verify structure after alignment
# if (exists("metabolite_data_cln")) {
#   log_info("Structure of 'metabolite_data_cln' after alignment attempt:")
#   str(metabolite_data_cln)
# }
```

# Create the MetabolomicsQuantitativeData S4 object
## Initializes the S4 object to store quantitative data, metadata, and configuration.

```{r Metabolite Data S4 Object Creation}
metabolite_design_matrix <- design_matrix
# Create the object using the new constructor and specified column names
metabolite_data_obj <- createMetaboliteAssayData(
    metabolite_data = metabolite_data_cln # Pass the list of metabolomics data frames
    , design_matrix = metabolite_design_matrix,
    metabolite_id_column = "database_identifier" # Specify primary ID col name in assays
    , annotation_id_column = "metabolite" # Specify annotation ID col name
    , sample_id = "Run" # Specify sample ID col name in design_matrix
    , group_id = "group" # Specify group col name in design_matrix
    , technical_replicate_id = "replicates" # Use NA_character_ if tech rep column name is NA
    , database_identifier_type = "CHEBI" # Specify type of ID in annotation_id_column
    # (e.g., "HMDB", "KEGG", "CHEBI", "Mixed_CHEBI_Unknown", "InternalName").
    , internal_standard_regex = "ITSD" # Specify regex (e.g IS in metabolite_id_column).
    ## IF NO IS, SET TO NA
    , args = config_list
)

# str(metabolite_data_obj) # Check the structure of the S4 object
```

# Fetch Metabolite Annotations
## Retrieves annotations (e.g., KEGG pathways, chemical properties) based on metabolite identifiers (ChEBI ID, Name, etc.).

```{r Metabolite Annotation}
# This requires a new function: getMetaboliteAnnotations
# Input: feature_metadata_cln, id_column (e.g., 'ChEBI_ID', 'MetaboliteName'), annotation_source ('ChEBI', 'KEGG', 'PubChem')
# Output: Enriched feature_metadata_cln table

# Placeholder function call - ** THIS FUNCTION NEEDS TO BE IMPLEMENTED **
# It should handle different ID types and query relevant databases (KEGGREST, webchem, etc.)
# Consider caching results to avoid repeated queries (like getUniprotAnnotations)
# feature_metadata_annotated <- getMetaboliteAnnotations(
#   feature_metadata = feature_metadata_cln,
#   metabolite_id_column = config_list$globalParameters$metabolite_id_column, # Or a specific annotation ID column like 'ChEBI_ID'
#   feature_name_column = config_list$globalParameters$feature_name_column,
#   annotation_source = config_list$globalParameters$annotation_source,
#   kegg_organism_code = config_list$globalParameters$organism_kegg_code,
#   cache_dir = file.path(results_dir, "tmp_folder")
# )

# --- Placeholder Implementation ---
log_warn("getMetaboliteAnnotations function not implemented. Using existing metadata.")
feature_metadata_annotated <- feature_metadata_cln
# Add mock columns if needed for downstream steps
if (!"KEGG_ID" %in% names(feature_metadata_annotated)) feature_metadata_annotated$KEGG_ID <- NA
if (!"Pathway" %in% names(feature_metadata_annotated)) feature_metadata_annotated$Pathway <- NA
if (!"Formula" %in% names(feature_metadata_annotated)) feature_metadata_annotated$Formula <- NA
if (!config_list$globalParameters$feature_name_column %in% names(feature_metadata_annotated)) {
    # Use the ID column as name if specific name column doesn't exist
    feature_metadata_annotated[[config_list$globalParameters$feature_name_column]] <- feature_metadata_annotated$rowname_id
}
# --- End Placeholder ---

log_info("Feature metadata annotated (placeholder). Dimensions: {nrow(feature_metadata_annotated)} x {ncol(feature_metadata_annotated)}")

# Ensure row order hasn't changed and still matches data_cln
stopifnot(identical(rownames(data_cln), feature_metadata_annotated$rowname_id))

# Make the primary metabolite ID the rownames for SE object compatibility
rownames(feature_metadata_annotated) <- feature_metadata_annotated$rowname_id
```

# Raw Data QC
## Initial quality control checks and filtering steps on the raw data.
## We need an equivalent to `updateProteinFiltering` for metabolites.

```{r Raw Data QC and Filtering}
# Track raw data state

rm(raw_data_qc_stats)
raw_data_qc_stats <- updateMetaboliteFiltering(
    theObject = metabolite_data_obj,
    step_name = "1_Raw_Data",
    omics_type = "metabolomics", # Just specify this
    return_grid = TRUE,
    overwrite = TRUE
)
```

```{r Metabolite Intensity Filtering}
    # Assuming 'metabolite_data_obj' is your MetaboliteAssayData object
    metabolite_normalised_mif_cln <- metaboliteIntensityFiltering(metabolite_data_obj) 


raw_data_qc_stats <- updateMetaboliteFiltering(
    theObject = metabolite_normalised_mif_cln,
    step_name = "2_IntesityFiltered_Data",
    omics_type = "metabolomics", # Just specify this
    return_grid = TRUE,
    overwrite = TRUE
)

```


```{r Remove Duplicate Features By Intensity}

metabolite_normalised_duplicates_removed <- resolveDuplicateFeatures(metabolite_normalised_mif_cln,
        itsd_pattern_columns = c("metabolite", "metabolite_identification")
    )

    duplicates_report <- findDuplicateFeatureIDs(metabolite_normalised_duplicates_removed)
    print(duplicates_report)



raw_data_qc_stats <- updateMetaboliteFiltering(
    theObject = metabolite_normalised_duplicates_removed,
    step_name = "3_DuplicatesRemoved",
    omics_type = "metabolomics", # Just specify this
    return_grid = TRUE,
    overwrite = TRUE
)


```

```{r}

# --- Internal Standard Normalization ---

#' @title Normalize Untransformed Data Generic
#'
#' @description
#' Defines the generic function for applying normalization methods directly to
#' untransformed (or potentially pre-transformed but not log2) quantitative data
#' within assay objects, primarily focusing on Internal Standard (ITSD) normalization.
#'
#' @param theObject The data object (e.g., MetaboliteAssayData).
#' @param method The normalization method to apply (currently supports "ITSD").
#' @param ... Additional arguments passed to specific methods.
#'
#' @return An updated object with normalized quantitative data.
#' @export
setGeneric(name = "normaliseUntransformedData",
           def = function(theObject, method = "ITSD", ...) {
             standardGeneric("normaliseUntransformedData")
           }
)

#' @title Normalize by Internal Standard (ITSD) for MetaboliteAssayData
#'
#' @description
#' Normalizes the untransformed metabolite intensity data in each assay of a
#' `MetaboliteAssayData` object using Internal Standards (ITSDs).
#'
#' @details
#' This method corrects for systematic variations between samples (e.g., differences
#' in sample loading or instrument sensitivity) based on the signal of Internal
#' Standards (ITSDs). The process involves:
#' 1. Identifying ITSD features using a regex pattern (`internal_standard_regex` slot)
#'    applied to specified annotation columns (`itsd_pattern_columns`).
#' 2. Calculating an aggregate ITSD signal for *each sample* by combining the
#'    intensities of all identified ITSDs within that sample. The aggregation method
#'    is chosen via `itsd_aggregation` ("sum", "mean", or "median").
#' 3. Calculating the *average* of these aggregate ITSD signals across *all samples*.
#' 4. For each sample, calculating a normalization factor:
#'    `Factor = Average_Aggregate_ITSD / Sample_Aggregate_ITSD`.
#' 5. Multiplying the intensity of every non-ITSD feature in that sample by this
#'    sample-specific `Factor`.
#'
#' This method operates on the raw (or previously normalized, but typically not
#' log-transformed) data in the `metabolite_data` slot. It aims to preserve the
#' overall scale of the data while adjusting relative differences between samples,
#' centering the normalized data around the average ITSD response observed.
#'
#' Assays where no ITSDs are found will issue a warning and remain unchanged. Samples
#' where the aggregate ITSD signal is zero or NA will also result in warnings,
#' and the normalized values for those samples will likely become NA.
#'
#' @describeIn normaliseUntransformedData Method for MetaboliteAssayData using ITSD
#'
#' @param theObject A `MetaboliteAssayData` object.
#' @param method Must be "ITSD" for this method.
#' @param itsd_pattern_columns A character vector specifying the column names within
#'   each assay tibble where the ITSD pattern should be searched. If `NULL` (default),
#'   it uses the column name stored in the `annotation_id_column` slot of the object.
#' @param itsd_aggregation The method used to aggregate intensities of multiple ITSDs
#'   within each sample. Options are "sum" (default),
#'   "mean", or "median".
#' @param remove_itsd_after_norm Logical (default: TRUE). If TRUE, rows identified as
#'   ITSDs are removed from the assay tibbles after normalization is complete.
#' @param ... Currently unused.
#'
#' @return An updated `MetaboliteAssayData` object with ITSD-normalized values in the
#'   `metabolite_data` slot. Normalization status is recorded in the `args` slot.
#'
#' @importFrom dplyr mutate across all_of filter select matches summarise group_by pull if_else
#' @importFrom tidyr pivot_longer pivot_wider
#' @importFrom rlang sym !! := .data
#' @importFrom purrr map set_names reduce
#' @importFrom methods slot slot<- is
#' @importFrom tibble as_tibble is_tibble tibble
#' @importFrom stringr str_detect
#'
#' @export
setMethod(f = "normaliseUntransformedData",
          signature = signature(theObject = "MetaboliteAssayData", method = "character"),
          definition = function(theObject,
                                method = "ITSD",
                                itsd_pattern_columns = NULL, # Default set later
                                itsd_aggregation = "sum",
                                remove_itsd_after_norm = TRUE,
                                ...) {

            # --- Input Validation ---
            if (tolower(method) != "itsd") {
                stop("This method currently only supports method = 'ITSD'.")
            }
            valid_aggregations <- c("sum", "mean", "median")
            if (!tolower(itsd_aggregation) %in% valid_aggregations) {
                stop(sprintf("`itsd_aggregation` must be one of: %s", paste(valid_aggregations, collapse = ", ")))
            }
            itsd_aggregation_func <- switch(tolower(itsd_aggregation),
                                            "sum" = sum,
                                            "mean" = mean,
                                            "median" = stats::median)
            message(sprintf("Applying Internal Standard (ITSD) normalization using '%s' aggregation and scaling to average ITSD response.", tolower(itsd_aggregation)))

            # --- Get Object Slots ---
            assay_list <- methods::slot(theObject, "metabolite_data")
            metabolite_id_col <- methods::slot(theObject, "metabolite_id_column")
            design_matrix <- methods::slot(theObject, "design_matrix")
            sample_id_col <- methods::slot(theObject, "sample_id")
            itsd_regex <- methods::slot(theObject, "internal_standard_regex")
            annotation_col <- methods::slot(theObject, "annotation_id_column") # Default ITSD column

            # Set default for itsd_pattern_columns if NULL
            if (is.null(itsd_pattern_columns)) {
                itsd_pattern_columns <- annotation_col
                message(sprintf("Using default annotation column '%s' to identify ITSDs.", annotation_col))
            } else {
                 message(sprintf("Using column(s) '%s' to identify ITSDs.", paste(itsd_pattern_columns, collapse="', '")))
            }

            if (length(assay_list) == 0) {
              warning("MetaboliteAssayData object has no assays in 'metabolite_data' slot. No normalization performed.")
              return(theObject)
            }
             if (is.null(itsd_regex) || itsd_regex == "") {
                 stop("The `internal_standard_regex` slot is empty. Cannot identify ITSDs.")
             }


            # Ensure list is named
            original_assay_names <- names(assay_list)
             if (is.null(original_assay_names)) {
                 names(assay_list) <- paste0("Assay_", seq_along(assay_list))
                 warning("Assay list was unnamed. Using default names (Assay_1, Assay_2, ...).", immediate. = TRUE)
             } else if (any(original_assay_names == "")) {
                 needs_name <- which(original_assay_names == "")
                 original_assay_names[needs_name] <- paste0("Assay_", needs_name)
                 names(assay_list) <- original_assay_names
                 warning("Some assays were unnamed. Using default names for them.", immediate. = TRUE)
             }
             assay_names <- names(assay_list) # Use the potentially corrected names

            # --- Identify Sample Columns ---
            if (!methods::is(design_matrix, "data.frame")) {
              stop("Slot 'design_matrix' is not a data.frame.")
            }
            if (!sample_id_col %in% colnames(design_matrix)) {
               stop(sprintf("Sample ID column '%s' not found in design_matrix. Cannot identify sample columns for normalization.", sample_id_col))
            }
            design_samples <- tryCatch(as.character(design_matrix[[sample_id_col]]), error = function(e){
               stop(sprintf("Could not extract sample IDs from design_matrix column '%s': %s", sample_id_col, e$message))
            })
            if (length(design_samples) == 0) {
                 stop("No sample IDs found in the design matrix.")
            }


            # --- Process Each Assay ---
            normalized_assay_list <- lapply(seq_along(assay_list), function(i) {
                assay_index_name <- assay_names[i] # Use the name from the corrected list
                assay_tibble <- assay_list[[i]]
                 message(sprintf("-- Processing assay: %s", assay_index_name))

                 # --- Basic Checks ---
                 if (!tibble::is_tibble(assay_tibble)) {
                     warning(sprintf("Assay '%s' is not a tibble. Attempting to coerce.", assay_index_name), immediate. = TRUE)
                     assay_tibble <- tryCatch(tibble::as_tibble(assay_tibble), error = function(e) {
                         warning(sprintf("Failed to coerce assay '%s' to tibble: %s. Skipping normalization.", assay_index_name, e$message), immediate. = TRUE)
                         return(NULL) # Signal to skip this assay
                     })
                     if (is.null(assay_tibble)) return(assay_list[[i]]) # Return original if coercion failed
                 }
                if (!metabolite_id_col %in% colnames(assay_tibble)) {
                    warning(sprintf("Assay '%s': Metabolite ID column '%s' not found. Skipping normalization.", assay_index_name, metabolite_id_col), immediate. = TRUE)
                    return(assay_tibble)
                }
                 # Check if *any* of the itsd_pattern_columns exist
                 if (!any(itsd_pattern_columns %in% colnames(assay_tibble))) {
                    warning(sprintf("Assay '%s': None of the specified ITSD pattern columns ('%s') found. Cannot identify ITSDs. Skipping normalization.",
                                    assay_index_name, paste(itsd_pattern_columns, collapse="', '")), immediate. = TRUE)
                    return(assay_tibble)
                 }
                 # Filter itsd_pattern_columns to only those present in the current assay
                 actual_itsd_cols <- intersect(itsd_pattern_columns, colnames(assay_tibble))
                  if (length(actual_itsd_cols) == 0) { # Should be caught above, but double check
                      warning(sprintf("Assay '%s': No ITSD identification columns found after checking existence. Skipping normalization.", assay_index_name), immediate. = TRUE)
                      return(assay_tibble)
                  }


                # --- Identify Sample Columns in this Assay ---
                 all_assay_cols <- colnames(assay_tibble)
                 sample_cols <- intersect(all_assay_cols, design_samples)
                 if (length(sample_cols) == 0) {
                     warning(sprintf("Assay '%s': No sample columns identified matching design matrix sample IDs. Skipping normalization.", assay_index_name), immediate. = TRUE)
                     return(assay_tibble)
                 }
                 # Ensure sample columns are numeric
                 non_numeric_samples <- sample_cols[!sapply(assay_tibble[sample_cols], is.numeric)]
                 if (length(non_numeric_samples) > 0) {
                    warning(sprintf("Assay '%s': Non-numeric sample columns found: %s. Attempting coercion, but this may indicate upstream issues.",
                                    assay_index_name, paste(non_numeric_samples, collapse=", ")), immediate. = TRUE)
                    assay_tibble <- assay_tibble |>
                        dplyr::mutate(dplyr::across(dplyr::all_of(non_numeric_samples), as.numeric))
                 }

                 # --- Identify ITSD Rows ---
                 itsd_rows_logical <- assay_tibble |>
                    dplyr::select(dplyr::all_of(actual_itsd_cols)) |>
                    dplyr::mutate(dplyr::across(dplyr::everything(), ~ stringr::str_detect(as.character(.), itsd_regex))) |>
                    # Row is ITSD if pattern matches in *any* of the specified columns
                    purrr::reduce(`|`)

                 if (!any(itsd_rows_logical, na.rm = TRUE)) {
                     warning(sprintf("Assay '%s': No ITSD features identified using regex '%s' in columns '%s'. Skipping normalization.",
                                     assay_index_name, itsd_regex, paste(actual_itsd_cols, collapse="', '")), immediate. = TRUE)
                     return(assay_tibble)
                 }
                 itsd_data <- assay_tibble |> dplyr::filter(itsd_rows_logical)
                 non_itsd_data <- assay_tibble |> dplyr::filter(!itsd_rows_logical)
                 n_itsd <- nrow(itsd_data)
                 message(sprintf("   Identified %d ITSD features.", n_itsd))

                # --- Calculate Normalization Factors ---
                # Step 1: Calculate aggregate ITSD per sample
                norm_factors_long <- tryCatch({
                    itsd_data |>
                        dplyr::select(dplyr::all_of(c(metabolite_id_col, sample_cols))) |>
                        tidyr::pivot_longer(cols = dplyr::all_of(sample_cols), names_to = "Sample", values_to = "Intensity") |>
                        dplyr::group_by(.data$Sample) |>
                        # Aggregate ITSD intensities per sample
                        # Use SampleNormFactor to be clear about the value's meaning
                        dplyr::summarise(SampleNormFactor = itsd_aggregation_func(.data$Intensity, na.rm = TRUE), .groups = "drop")
                }, error = function(e) {
                     warning(sprintf("Assay '%s': Error calculating normalization factors: %s. Skipping normalization.", assay_index_name, e$message), immediate. = TRUE)
                     return(NULL)
                 })
                if (is.null(norm_factors_long)) return(assay_tibble) # Return original on error

                # Check for zero or NA factors
                problematic_factors <- norm_factors_long |>
                    dplyr::filter(is.na(.data$SampleNormFactor) | .data$SampleNormFactor == 0)
                if (nrow(problematic_factors) > 0) {
                    warning(sprintf("Assay '%s': Aggregate ITSD signal (SampleNormFactor) is NA or zero for samples: %s. Normalized values will be NA for these samples.",
                                    assay_index_name, paste(problematic_factors$Sample, collapse=", ")), immediate. = TRUE)
                    # Set factor to NA to ensure division results in NA
                    norm_factors_long <- norm_factors_long |>
                        dplyr::mutate(SampleNormFactor = dplyr::if_else(is.na(.data$SampleNormFactor) | .data$SampleNormFactor == 0, NA_real_, .data$SampleNormFactor))
                }

                # Step 2: Calculate the average aggregate ITSD signal across all samples
                average_norm_factor <- mean(norm_factors_long$SampleNormFactor, na.rm = TRUE)
                 if (is.na(average_norm_factor) || average_norm_factor == 0) {
                     warning(sprintf("Assay '%s': Average aggregate ITSD signal is NA or zero. Cannot perform average-centered normalization. Skipping.", assay_index_name), immediate. = TRUE)
                     return(assay_tibble)
                 }

                # Create a named vector for easy lookup (Sample -> NormFactor)
                sample_norm_factors_vec <- stats::setNames(norm_factors_long$SampleNormFactor, norm_factors_long$Sample)

                # --- Apply Normalization ---
                 message(sprintf("   Applying normalization to %d non-ITSD features...", nrow(non_itsd_data)))
                 normalized_non_itsd_data <- tryCatch({
                    non_itsd_data |>
                        dplyr::mutate(dplyr::across(dplyr::all_of(sample_cols),
                                             # Multiply intensity by (Average Factor / Sample Factor)
                                             ~ .x * (average_norm_factor / sample_norm_factors_vec[dplyr::cur_column()])))
                 }, error = function(e) {
                     warning(sprintf("Assay '%s': Error applying normalization factors: %s. Returning unnormalized data for non-ITSD features.", assay_index_name, e$message), immediate. = TRUE)
                     return(non_itsd_data) # Return unnormalized if error
                 })

                # --- Reconstruct Assay Tibble ---
                if (remove_itsd_after_norm) {
                    final_assay_tibble <- normalized_non_itsd_data
                    message(sprintf("   Removed %d ITSD features after normalization.", n_itsd))
                } else {
                    # If keeping ITSDs, they remain unnormalized (or could be normalized like others)
                    # Here, we keep them unnormalized as their purpose was the factor calculation.
                    final_assay_tibble <- dplyr::bind_rows(normalized_non_itsd_data, itsd_data) |>
                        # Optional: arrange back by original ID or similar if needed
                         dplyr::arrange(!!rlang::sym(metabolite_id_col))
                    message(sprintf("   Kept %d ITSD features (unnormalized) in the output.", n_itsd))
                }

                 message(sprintf("   Assay '%s' normalization complete.", assay_index_name))
                 return(final_assay_tibble)
            }) # End lapply

            # Filter out any assays that failed (returned NULL - though currently returning original)
            # This check might be redundant if errors return original, but good practice.
            successful_assays <- !sapply(normalized_assay_list, is.null)
             if (!all(successful_assays)) {
                 warning("Normalization failed or was skipped for some assays.", immediate. = TRUE)
                 # Keep original data for failed assays
                 normalized_assay_list[!successful_assays] <- assay_list[!successful_assays]
             }


            # Restore original names if they existed
            names(normalized_assay_list) <- assay_names

            # Assign the list of normalized assays back to the object
            methods::slot(theObject, "metabolite_data") <- normalized_assay_list

            # --- Update Args Slot ---
            if (!is.list(theObject@args)) {
                warning("Slot 'args' is not a list. Cannot record ITSD normalization status.", immediate. = TRUE)
            } else {
                 # Ensure the specific list exists
                if (!"ITSDNormalization" %in% names(theObject@args)) {
                    theObject@args$ITSDNormalization <- list()
                }
                theObject@args$ITSDNormalization$applied <- TRUE
                theObject@args$ITSDNormalization$method_type <- "average_centered"
                theObject@args$ITSDNormalization$itsd_aggregation <- tolower(itsd_aggregation)
                theObject@args$ITSDNormalization$itsd_pattern_columns <- itsd_pattern_columns # Record actual columns used (potentially default)
                theObject@args$ITSDNormalization$removed_itsd <- remove_itsd_after_norm
                theObject@args$ITSDNormalization$timestamp <- Sys.time()
            }

            message("ITSD normalization process complete for all applicable assays.")
            return(theObject)
          }
)

# Optional: Add other normalization methods (e.g., PQN, Median) here later
# setMethod(f = "normaliseUntransformedData",
#           signature = signature(theObject = "MetaboliteAssayData", method = "character"),
#           definition = function(theObject, method = "PQN", ...) { ... }
# ) 
```


```{r 4 ITSD Normalisation}

metabolite_itsd_normalised <- normaliseUntransformedData(
    metabolite_normalised_duplicates_removed,
    method = "ITSD",
    itsd_pattern_columns = c("metabolite", "metabolite_identification"),
    itsd_aggregation = "mean", # Default is sum, can change to "mean" or "median"
    remove_itsd_after_norm = FALSE # Default is TRUE
)

raw_data_qc_stats <- updateMetaboliteFiltering(
    theObject = metabolite_itsd_normalised,
    step_name = "4_ITSD_Normalised",
    omics_type = "metabolomics", # Just specify this
    return_grid = TRUE,
    overwrite = TRUE
)

```

```{r 5 Log Transform Data}
metabolite_itsd_log_transformed <- logTransformAssays(metabolite_itsd_normalised)

raw_data_qc_stats <- updateMetaboliteFiltering(
    theObject = metabolite_itsd_log_transformed,
    step_name = "5_ITSD_Log2Transformed",
    omics_type = "metabolomics", # Just specify this
    return_grid = TRUE,
    overwrite = TRUE
)
```


```{r Pre-Normalisation QC}
QC_composite_figure <- InitialiseGrid()

QC_composite_figure@rle_plots$rle_plot_before_ITSD <- plotRle(
  metabolite_itsd_log_transformed,
  "group",
  yaxis_limit = c(-6, 6)
)

QC_composite_figure@pca_plots$pca_plot_before_ITSD <- plotPca(
  metabolite_itsd_log_transformed,
  grouping_variable = "group",
  label_column = "",
  shape_variable = "group",
  title = "",
  font_size = 8
)



QC_composite_figure@density_plots$pca_plot_before_ITSD <- plotDensity(
  QC_composite_figure@pca_plots$pca_plot_before_ITSD,
  grouping_variable = "group"
)

#QC_composite_figure@density_plots$pca_plot_before_ITSD


#pca_mixomics_before_cyclic_loess <- getPcaMatrix(remove_proteins_with_only_one_rep)

QC_composite_figure@pearson_plots$pearson_correlation_pair_before_ITSD <-
  plotPearson(
    metabolite_itsd_log_transformed,
    tech_rep_remove_regex = "pool",
    correlation_group = "group"
  )


summarizeQCPlot(QC_composite_figure)

savePlot(
  QC_composite_figure@rle_plots$rle_plot_before_cyclic_loess,
  protein_qc_dir,
  "rle_plot_before_cyclic_loess"
)
savePlot(
  QC_composite_figure@pca_plots$pca_plot_before_cyclic_loess_group,
  protein_qc_dir,
  "pca_plot_before_cyclic_loess"
)
savePlot(
  QC_composite_figure@density_plots$density_plot_before_cyclic_loess_group,
  protein_qc_dir,
  "density_plot_before_cyclic_loess"
)
savePlot(
  QC_composite_figure@pearson_plots$pearson_correlation_pair_before_cyclic_loess,
  protein_qc_dir,
  "pearson_correlation_pair_before_cyclic_loess"
)

#frozen_protein_matrix_tech_rep <- proteinTechRepCorrelation(
#  remove_proteins_with_only_one_rep,
#  tech_rep_num_column = "group",
#  tech_rep_remove_regex = "pool"
#)
```

# Cyclic Loess Normaliation

```{r Cyclic Loess Normaliation}
# Assuming metabolite_itsd_log_transformed is your log-transformed MetaboliteAssayData object
metabolite_cyclicloess_normalised <- normaliseBetweenSamples(
    metabolite_itsd_log_transformed,
    normalisation_method = "cyclicloess" # Or "quantile", "scale", "none", or NULL to use config
)


QC_composite_figure@rle_plots$rle_plot_before_RUVIIc <- plotRle(
  metabolite_cyclicloess_normalised,
  "group",
  yaxis_limit = c(-6, 6)
)

QC_composite_figure@pca_plots$pca_plot_before_RUVIIc <- plotPca(
  metabolite_cyclicloess_normalised,
  grouping_variable = "group",
  label_column = "",
  shape_variable = "group",
  title = "",
  font_size = 8
)



QC_composite_figure@density_plots$pca_plot_before_RUVIIc <- plotDensity(
  QC_composite_figure@pca_plots$pca_plot_before_RUVIIc,
  grouping_variable = "group"
)

#QC_composite_figure@density_plots$pca_plot_before_ITSD


#pca_mixomics_before_cyclic_loess <- getPcaMatrix(remove_proteins_with_only_one_rep)

QC_composite_figure@pearson_plots$pearson_correlation_pair_before_RUVIIc <-
  plotPearson(
    metabolite_cyclicloess_normalised,
    tech_rep_remove_regex = "pool",
    correlation_group = "group"
  )


summarizeQCPlot(QC_composite_figure)
```